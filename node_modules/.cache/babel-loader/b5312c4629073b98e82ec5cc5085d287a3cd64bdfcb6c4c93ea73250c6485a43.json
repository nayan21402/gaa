{"ast":null,"code":"// ------------------------------------------\n// Rellax.js\n// Buttery smooth parallax library\n// Copyright (c) 2016 Moe Amaya (@moeamaya)\n// MIT license\n//\n// Thanks to Paraxify.js and Jaime Cabllero\n// for parallax concepts\n// ------------------------------------------\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.Rellax = factory();\n  }\n})(typeof window !== \"undefined\" ? window : global, function () {\n  var Rellax = function (el, options) {\n    \"use strict\";\n\n    var self = Object.create(Rellax.prototype);\n    var posY = 0;\n    var screenY = 0;\n    var posX = 0;\n    var screenX = 0;\n    var blocks = [];\n    var pause = true;\n\n    // check what requestAnimationFrame to use, and if\n    // it's not supported, use the onscroll event\n    var loop = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function (callback) {\n      return setTimeout(callback, 1000 / 60);\n    };\n\n    // store the id for later use\n    var loopId = null;\n\n    // Test via a getter in the options object to see if the passive property is accessed\n    var supportsPassive = false;\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function () {\n          supportsPassive = true;\n        }\n      });\n      window.addEventListener(\"testPassive\", null, opts);\n      window.removeEventListener(\"testPassive\", null, opts);\n    } catch (e) {}\n\n    // check what cancelAnimation method to use\n    var clearLoop = window.cancelAnimationFrame || window.mozCancelAnimationFrame || clearTimeout;\n\n    // check which transform property to use\n    var transformProp = window.transformProp || function () {\n      var testEl = document.createElement('div');\n      if (testEl.style.transform === null) {\n        var vendors = ['Webkit', 'Moz', 'ms'];\n        for (var vendor in vendors) {\n          if (testEl.style[vendors[vendor] + 'Transform'] !== undefined) {\n            return vendors[vendor] + 'Transform';\n          }\n        }\n      }\n      return 'transform';\n    }();\n\n    // Default Settings\n    self.options = {\n      speed: -2,\n      verticalSpeed: null,\n      horizontalSpeed: null,\n      breakpoints: [576, 768, 1201],\n      center: false,\n      wrapper: null,\n      relativeToWrapper: false,\n      round: true,\n      vertical: true,\n      horizontal: false,\n      verticalScrollAxis: \"y\",\n      horizontalScrollAxis: \"x\",\n      callback: function () {}\n    };\n\n    // User defined options (might have more in the future)\n    if (options) {\n      Object.keys(options).forEach(function (key) {\n        self.options[key] = options[key];\n      });\n    }\n    function validateCustomBreakpoints() {\n      if (self.options.breakpoints.length === 3 && Array.isArray(self.options.breakpoints)) {\n        var isAscending = true;\n        var isNumerical = true;\n        var lastVal;\n        self.options.breakpoints.forEach(function (i) {\n          if (typeof i !== 'number') isNumerical = false;\n          if (lastVal !== null) {\n            if (i < lastVal) isAscending = false;\n          }\n          lastVal = i;\n        });\n        if (isAscending && isNumerical) return;\n      }\n      // revert defaults if set incorrectly\n      self.options.breakpoints = [576, 768, 1201];\n      console.warn(\"Rellax: You must pass an array of 3 numbers in ascending order to the breakpoints option. Defaults reverted\");\n    }\n    if (options && options.breakpoints) {\n      validateCustomBreakpoints();\n    }\n\n    // By default, rellax class\n    if (!el) {\n      el = '.rellax';\n    }\n\n    // check if el is a className or a node\n    var elements = typeof el === 'string' ? document.querySelectorAll(el) : [el];\n\n    // Now query selector\n    if (elements.length > 0) {\n      self.elems = elements;\n    }\n\n    // The elements don't exist\n    else {\n      console.warn(\"Rellax: The elements you're trying to select don't exist.\");\n      return;\n    }\n\n    // Has a wrapper and it exists\n    if (self.options.wrapper) {\n      if (!self.options.wrapper.nodeType) {\n        var wrapper = document.querySelector(self.options.wrapper);\n        if (wrapper) {\n          self.options.wrapper = wrapper;\n        } else {\n          console.warn(\"Rellax: The wrapper you're trying to use doesn't exist.\");\n          return;\n        }\n      }\n    }\n\n    // set a placeholder for the current breakpoint\n    var currentBreakpoint;\n\n    // helper to determine current breakpoint\n    var getCurrentBreakpoint = function (w) {\n      var bp = self.options.breakpoints;\n      if (w < bp[0]) return 'xs';\n      if (w >= bp[0] && w < bp[1]) return 'sm';\n      if (w >= bp[1] && w < bp[2]) return 'md';\n      return 'lg';\n    };\n\n    // Get and cache initial position of all elements\n    var cacheBlocks = function () {\n      for (var i = 0; i < self.elems.length; i++) {\n        var block = createBlock(self.elems[i]);\n        blocks.push(block);\n      }\n    };\n\n    // Let's kick this script off\n    // Build array for cached element values\n    var init = function () {\n      for (var i = 0; i < blocks.length; i++) {\n        self.elems[i].style.cssText = blocks[i].style;\n      }\n      blocks = [];\n      screenY = window.innerHeight;\n      screenX = window.innerWidth;\n      currentBreakpoint = getCurrentBreakpoint(screenX);\n      setPosition();\n      cacheBlocks();\n      animate();\n\n      // If paused, unpause and set listener for window resizing events\n      if (pause) {\n        window.addEventListener('resize', init);\n        pause = false;\n        // Start the loop\n        update();\n      }\n    };\n\n    // We want to cache the parallax blocks'\n    // values: base, top, height, speed\n    // el: is dom object, return: el cache values\n    var createBlock = function (el) {\n      var dataPercentage = el.getAttribute('data-rellax-percentage');\n      var dataSpeed = el.getAttribute('data-rellax-speed');\n      var dataXsSpeed = el.getAttribute('data-rellax-xs-speed');\n      var dataMobileSpeed = el.getAttribute('data-rellax-mobile-speed');\n      var dataTabletSpeed = el.getAttribute('data-rellax-tablet-speed');\n      var dataDesktopSpeed = el.getAttribute('data-rellax-desktop-speed');\n      var dataVerticalSpeed = el.getAttribute('data-rellax-vertical-speed');\n      var dataHorizontalSpeed = el.getAttribute('data-rellax-horizontal-speed');\n      var dataVericalScrollAxis = el.getAttribute('data-rellax-vertical-scroll-axis');\n      var dataHorizontalScrollAxis = el.getAttribute('data-rellax-horizontal-scroll-axis');\n      var dataZindex = el.getAttribute('data-rellax-zindex') || 0;\n      var dataMin = el.getAttribute('data-rellax-min');\n      var dataMax = el.getAttribute('data-rellax-max');\n      var dataMinX = el.getAttribute('data-rellax-min-x');\n      var dataMaxX = el.getAttribute('data-rellax-max-x');\n      var dataMinY = el.getAttribute('data-rellax-min-y');\n      var dataMaxY = el.getAttribute('data-rellax-max-y');\n      var mapBreakpoints;\n      var breakpoints = true;\n      if (!dataXsSpeed && !dataMobileSpeed && !dataTabletSpeed && !dataDesktopSpeed) {\n        breakpoints = false;\n      } else {\n        mapBreakpoints = {\n          'xs': dataXsSpeed,\n          'sm': dataMobileSpeed,\n          'md': dataTabletSpeed,\n          'lg': dataDesktopSpeed\n        };\n      }\n\n      // initializing at scrollY = 0 (top of browser), scrollX = 0 (left of browser)\n      // ensures elements are positioned based on HTML layout.\n      //\n      // If the element has the percentage attribute, the posY and posX needs to be\n      // the current scroll position's value, so that the elements are still positioned based on HTML layout\n      var wrapperPosY = self.options.wrapper ? self.options.wrapper.scrollTop : window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;\n      // If the option relativeToWrapper is true, use the wrappers offset to top, subtracted from the current page scroll.\n      if (self.options.relativeToWrapper) {\n        var scrollPosY = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;\n        wrapperPosY = scrollPosY - self.options.wrapper.offsetTop;\n      }\n      var posY = self.options.vertical ? dataPercentage || self.options.center ? wrapperPosY : 0 : 0;\n      var posX = self.options.horizontal ? dataPercentage || self.options.center ? self.options.wrapper ? self.options.wrapper.scrollLeft : window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft : 0 : 0;\n      var blockTop = posY + el.getBoundingClientRect().top;\n      var blockHeight = el.clientHeight || el.offsetHeight || el.scrollHeight;\n      var blockLeft = posX + el.getBoundingClientRect().left;\n      var blockWidth = el.clientWidth || el.offsetWidth || el.scrollWidth;\n\n      // apparently parallax equation everyone uses\n      var percentageY = dataPercentage ? dataPercentage : (posY - blockTop + screenY) / (blockHeight + screenY);\n      var percentageX = dataPercentage ? dataPercentage : (posX - blockLeft + screenX) / (blockWidth + screenX);\n      if (self.options.center) {\n        percentageX = 0.5;\n        percentageY = 0.5;\n      }\n\n      // Optional individual block speed as data attr, otherwise global speed\n      var speed = breakpoints && mapBreakpoints[currentBreakpoint] !== null ? Number(mapBreakpoints[currentBreakpoint]) : dataSpeed ? dataSpeed : self.options.speed;\n      var verticalSpeed = dataVerticalSpeed ? dataVerticalSpeed : self.options.verticalSpeed;\n      var horizontalSpeed = dataHorizontalSpeed ? dataHorizontalSpeed : self.options.horizontalSpeed;\n\n      // Optional individual block movement axis direction as data attr, otherwise gobal movement direction\n      var verticalScrollAxis = dataVericalScrollAxis ? dataVericalScrollAxis : self.options.verticalScrollAxis;\n      var horizontalScrollAxis = dataHorizontalScrollAxis ? dataHorizontalScrollAxis : self.options.horizontalScrollAxis;\n      var bases = updatePosition(percentageX, percentageY, speed, verticalSpeed, horizontalSpeed);\n\n      // ~~Store non-translate3d transforms~~\n      // Store inline styles and extract transforms\n      var style = el.style.cssText;\n      var transform = '';\n\n      // Check if there's an inline styled transform\n      var searchResult = /transform\\s*:/i.exec(style);\n      if (searchResult) {\n        // Get the index of the transform\n        var index = searchResult.index;\n\n        // Trim the style to the transform point and get the following semi-colon index\n        var trimmedStyle = style.slice(index);\n        var delimiter = trimmedStyle.indexOf(';');\n\n        // Remove \"transform\" string and save the attribute\n        if (delimiter) {\n          transform = \" \" + trimmedStyle.slice(11, delimiter).replace(/\\s/g, '');\n        } else {\n          transform = \" \" + trimmedStyle.slice(11).replace(/\\s/g, '');\n        }\n      }\n      return {\n        baseX: bases.x,\n        baseY: bases.y,\n        top: blockTop,\n        left: blockLeft,\n        height: blockHeight,\n        width: blockWidth,\n        speed: speed,\n        verticalSpeed: verticalSpeed,\n        horizontalSpeed: horizontalSpeed,\n        verticalScrollAxis: verticalScrollAxis,\n        horizontalScrollAxis: horizontalScrollAxis,\n        style: style,\n        transform: transform,\n        zindex: dataZindex,\n        min: dataMin,\n        max: dataMax,\n        minX: dataMinX,\n        maxX: dataMaxX,\n        minY: dataMinY,\n        maxY: dataMaxY\n      };\n    };\n\n    // set scroll position (posY, posX)\n    // side effect method is not ideal, but okay for now\n    // returns true if the scroll changed, false if nothing happened\n    var setPosition = function () {\n      var oldY = posY;\n      var oldX = posX;\n      posY = self.options.wrapper ? self.options.wrapper.scrollTop : (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;\n      posX = self.options.wrapper ? self.options.wrapper.scrollLeft : (document.documentElement || document.body.parentNode || document.body).scrollLeft || window.pageXOffset;\n      // If option relativeToWrapper is true, use relative wrapper value instead.\n      if (self.options.relativeToWrapper) {\n        var scrollPosY = (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;\n        posY = scrollPosY - self.options.wrapper.offsetTop;\n      }\n      if (oldY != posY && self.options.vertical) {\n        // scroll changed, return true\n        return true;\n      }\n      if (oldX != posX && self.options.horizontal) {\n        // scroll changed, return true\n        return true;\n      }\n\n      // scroll did not change\n      return false;\n    };\n\n    // Ahh a pure function, gets new transform value\n    // based on scrollPosition and speed\n    // Allow for decimal pixel values\n    var updatePosition = function (percentageX, percentageY, speed, verticalSpeed, horizontalSpeed) {\n      var result = {};\n      var valueX = (horizontalSpeed ? horizontalSpeed : speed) * (100 * (1 - percentageX));\n      var valueY = (verticalSpeed ? verticalSpeed : speed) * (100 * (1 - percentageY));\n      result.x = self.options.round ? Math.round(valueX) : Math.round(valueX * 100) / 100;\n      result.y = self.options.round ? Math.round(valueY) : Math.round(valueY * 100) / 100;\n      return result;\n    };\n\n    // Remove event listeners and loop again\n    var deferredUpdate = function () {\n      window.removeEventListener('resize', deferredUpdate);\n      window.removeEventListener('orientationchange', deferredUpdate);\n      (self.options.wrapper ? self.options.wrapper : window).removeEventListener('scroll', deferredUpdate);\n      (self.options.wrapper ? self.options.wrapper : document).removeEventListener('touchmove', deferredUpdate);\n\n      // loop again\n      loopId = loop(update);\n    };\n\n    // Loop\n    var update = function () {\n      if (setPosition() && pause === false) {\n        animate();\n\n        // loop again\n        loopId = loop(update);\n      } else {\n        loopId = null;\n\n        // Don't animate until we get a position updating event\n        window.addEventListener('resize', deferredUpdate);\n        window.addEventListener('orientationchange', deferredUpdate);\n        (self.options.wrapper ? self.options.wrapper : window).addEventListener('scroll', deferredUpdate, supportsPassive ? {\n          passive: true\n        } : false);\n        (self.options.wrapper ? self.options.wrapper : document).addEventListener('touchmove', deferredUpdate, supportsPassive ? {\n          passive: true\n        } : false);\n      }\n    };\n\n    // Transform3d on parallax element\n    var animate = function () {\n      var positions;\n      for (var i = 0; i < self.elems.length; i++) {\n        // Determine relevant movement directions\n        var verticalScrollAxis = blocks[i].verticalScrollAxis.toLowerCase();\n        var horizontalScrollAxis = blocks[i].horizontalScrollAxis.toLowerCase();\n        var verticalScrollX = verticalScrollAxis.indexOf(\"x\") != -1 ? posY : 0;\n        var verticalScrollY = verticalScrollAxis.indexOf(\"y\") != -1 ? posY : 0;\n        var horizontalScrollX = horizontalScrollAxis.indexOf(\"x\") != -1 ? posX : 0;\n        var horizontalScrollY = horizontalScrollAxis.indexOf(\"y\") != -1 ? posX : 0;\n        var percentageY = (verticalScrollY + horizontalScrollY - blocks[i].top + screenY) / (blocks[i].height + screenY);\n        var percentageX = (verticalScrollX + horizontalScrollX - blocks[i].left + screenX) / (blocks[i].width + screenX);\n\n        // Subtracting initialize value, so element stays in same spot as HTML\n        positions = updatePosition(percentageX, percentageY, blocks[i].speed, blocks[i].verticalSpeed, blocks[i].horizontalSpeed);\n        var positionY = positions.y - blocks[i].baseY;\n        var positionX = positions.x - blocks[i].baseX;\n\n        // The next two \"if\" blocks go like this:\n        // Check if a limit is defined (first \"min\", then \"max\");\n        // Check if we need to change the Y or the X\n        // (Currently working only if just one of the axes is enabled)\n        // Then, check if the new position is inside the allowed limit\n        // If so, use new position. If not, set position to limit.\n\n        // Check if a min limit is defined\n        if (blocks[i].min !== null) {\n          if (self.options.vertical && !self.options.horizontal) {\n            positionY = positionY <= blocks[i].min ? blocks[i].min : positionY;\n          }\n          if (self.options.horizontal && !self.options.vertical) {\n            positionX = positionX <= blocks[i].min ? blocks[i].min : positionX;\n          }\n        }\n\n        // Check if directional min limits are defined\n        if (blocks[i].minY != null) {\n          positionY = positionY <= blocks[i].minY ? blocks[i].minY : positionY;\n        }\n        if (blocks[i].minX != null) {\n          positionX = positionX <= blocks[i].minX ? blocks[i].minX : positionX;\n        }\n\n        // Check if a max limit is defined\n        if (blocks[i].max !== null) {\n          if (self.options.vertical && !self.options.horizontal) {\n            positionY = positionY >= blocks[i].max ? blocks[i].max : positionY;\n          }\n          if (self.options.horizontal && !self.options.vertical) {\n            positionX = positionX >= blocks[i].max ? blocks[i].max : positionX;\n          }\n        }\n\n        // Check if directional max limits are defined\n        if (blocks[i].maxY != null) {\n          positionY = positionY >= blocks[i].maxY ? blocks[i].maxY : positionY;\n        }\n        if (blocks[i].maxX != null) {\n          positionX = positionX >= blocks[i].maxX ? blocks[i].maxX : positionX;\n        }\n        var zindex = blocks[i].zindex;\n\n        // Move that element\n        // (Set the new translation and append initial inline transforms.)\n        var translate = 'translate3d(' + (self.options.horizontal ? positionX : '0') + 'px,' + (self.options.vertical ? positionY : '0') + 'px,' + zindex + 'px) ' + blocks[i].transform;\n        self.elems[i].style[transformProp] = translate;\n      }\n      self.options.callback(positions);\n    };\n    self.destroy = function () {\n      for (var i = 0; i < self.elems.length; i++) {\n        self.elems[i].style.cssText = blocks[i].style;\n      }\n\n      // Remove resize event listener if not pause, and pause\n      if (!pause) {\n        window.removeEventListener('resize', init);\n        pause = true;\n      }\n\n      // Clear the animation loop to prevent possible memory leak\n      clearLoop(loopId);\n      loopId = null;\n    };\n\n    // Init\n    init();\n\n    // Allow to recalculate the initial values whenever we want\n    self.refresh = init;\n    return self;\n  };\n  return Rellax;\n});","map":{"version":3,"names":["root","factory","define","amd","module","exports","Rellax","window","global","el","options","self","Object","create","prototype","posY","screenY","posX","screenX","blocks","pause","loop","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","oRequestAnimationFrame","callback","setTimeout","loopId","supportsPassive","opts","defineProperty","get","addEventListener","removeEventListener","e","clearLoop","cancelAnimationFrame","mozCancelAnimationFrame","clearTimeout","transformProp","testEl","document","createElement","style","transform","vendors","vendor","undefined","speed","verticalSpeed","horizontalSpeed","breakpoints","center","wrapper","relativeToWrapper","round","vertical","horizontal","verticalScrollAxis","horizontalScrollAxis","keys","forEach","key","validateCustomBreakpoints","length","Array","isArray","isAscending","isNumerical","lastVal","i","console","warn","elements","querySelectorAll","elems","nodeType","querySelector","currentBreakpoint","getCurrentBreakpoint","w","bp","cacheBlocks","block","createBlock","push","init","cssText","innerHeight","innerWidth","setPosition","animate","update","dataPercentage","getAttribute","dataSpeed","dataXsSpeed","dataMobileSpeed","dataTabletSpeed","dataDesktopSpeed","dataVerticalSpeed","dataHorizontalSpeed","dataVericalScrollAxis","dataHorizontalScrollAxis","dataZindex","dataMin","dataMax","dataMinX","dataMaxX","dataMinY","dataMaxY","mapBreakpoints","wrapperPosY","scrollTop","pageYOffset","documentElement","body","scrollPosY","offsetTop","scrollLeft","pageXOffset","blockTop","getBoundingClientRect","top","blockHeight","clientHeight","offsetHeight","scrollHeight","blockLeft","left","blockWidth","clientWidth","offsetWidth","scrollWidth","percentageY","percentageX","Number","bases","updatePosition","searchResult","exec","index","trimmedStyle","slice","delimiter","indexOf","replace","baseX","x","baseY","y","height","width","zindex","min","max","minX","maxX","minY","maxY","oldY","oldX","parentNode","result","valueX","valueY","Math","deferredUpdate","passive","positions","toLowerCase","verticalScrollX","verticalScrollY","horizontalScrollX","horizontalScrollY","positionY","positionX","translate","destroy","refresh"],"sources":["C:/gaatha/node_modules/rellax/rellax.js"],"sourcesContent":["\n// ------------------------------------------\n// Rellax.js\n// Buttery smooth parallax library\n// Copyright (c) 2016 Moe Amaya (@moeamaya)\n// MIT license\n//\n// Thanks to Paraxify.js and Jaime Cabllero\n// for parallax concepts\n// ------------------------------------------\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.Rellax = factory();\n  }\n}(typeof window !== \"undefined\" ? window : global, function () {\n  var Rellax = function(el, options){\n    \"use strict\";\n\n    var self = Object.create(Rellax.prototype);\n\n    var posY = 0;\n    var screenY = 0;\n    var posX = 0;\n    var screenX = 0;\n    var blocks = [];\n    var pause = true;\n\n    // check what requestAnimationFrame to use, and if\n    // it's not supported, use the onscroll event\n    var loop = window.requestAnimationFrame ||\n      window.webkitRequestAnimationFrame ||\n      window.mozRequestAnimationFrame ||\n      window.msRequestAnimationFrame ||\n      window.oRequestAnimationFrame ||\n      function(callback){ return setTimeout(callback, 1000 / 60); };\n\n    // store the id for later use\n    var loopId = null;\n\n    // Test via a getter in the options object to see if the passive property is accessed\n    var supportsPassive = false;\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function() {\n          supportsPassive = true;\n        }\n      });\n      window.addEventListener(\"testPassive\", null, opts);\n      window.removeEventListener(\"testPassive\", null, opts);\n    } catch (e) {}\n\n    // check what cancelAnimation method to use\n    var clearLoop = window.cancelAnimationFrame || window.mozCancelAnimationFrame || clearTimeout;\n\n    // check which transform property to use\n    var transformProp = window.transformProp || (function(){\n        var testEl = document.createElement('div');\n        if (testEl.style.transform === null) {\n          var vendors = ['Webkit', 'Moz', 'ms'];\n          for (var vendor in vendors) {\n            if (testEl.style[ vendors[vendor] + 'Transform' ] !== undefined) {\n              return vendors[vendor] + 'Transform';\n            }\n          }\n        }\n        return 'transform';\n      })();\n\n    // Default Settings\n    self.options = {\n      speed: -2,\n\t    verticalSpeed: null,\n\t    horizontalSpeed: null,\n      breakpoints: [576, 768, 1201],\n      center: false,\n      wrapper: null,\n      relativeToWrapper: false,\n      round: true,\n      vertical: true,\n      horizontal: false,\n      verticalScrollAxis: \"y\",\n      horizontalScrollAxis: \"x\",\n      callback: function() {},\n    };\n\n    // User defined options (might have more in the future)\n    if (options){\n      Object.keys(options).forEach(function(key){\n        self.options[key] = options[key];\n      });\n    }\n\n    function validateCustomBreakpoints () {\n      if (self.options.breakpoints.length === 3 && Array.isArray(self.options.breakpoints)) {\n        var isAscending = true;\n        var isNumerical = true;\n        var lastVal;\n        self.options.breakpoints.forEach(function (i) {\n          if (typeof i !== 'number') isNumerical = false;\n          if (lastVal !== null) {\n            if (i < lastVal) isAscending = false;\n          }\n          lastVal = i;\n        });\n        if (isAscending && isNumerical) return;\n      }\n      // revert defaults if set incorrectly\n      self.options.breakpoints = [576, 768, 1201];\n      console.warn(\"Rellax: You must pass an array of 3 numbers in ascending order to the breakpoints option. Defaults reverted\");\n    }\n\n    if (options && options.breakpoints) {\n      validateCustomBreakpoints();\n    }\n\n    // By default, rellax class\n    if (!el) {\n      el = '.rellax';\n    }\n\n    // check if el is a className or a node\n    var elements = typeof el === 'string' ? document.querySelectorAll(el) : [el];\n\n    // Now query selector\n    if (elements.length > 0) {\n      self.elems = elements;\n    }\n\n    // The elements don't exist\n    else {\n      console.warn(\"Rellax: The elements you're trying to select don't exist.\");\n      return;\n    }\n\n    // Has a wrapper and it exists\n    if (self.options.wrapper) {\n      if (!self.options.wrapper.nodeType) {\n        var wrapper = document.querySelector(self.options.wrapper);\n\n        if (wrapper) {\n          self.options.wrapper = wrapper;\n        } else {\n          console.warn(\"Rellax: The wrapper you're trying to use doesn't exist.\");\n          return;\n        }\n      }\n    }\n\n    // set a placeholder for the current breakpoint\n    var currentBreakpoint;\n\n    // helper to determine current breakpoint\n    var getCurrentBreakpoint = function (w) {\n      var bp = self.options.breakpoints;\n      if (w < bp[0]) return 'xs';\n      if (w >= bp[0] && w < bp[1]) return 'sm';\n      if (w >= bp[1] && w < bp[2]) return 'md';\n      return 'lg';\n    };\n\n    // Get and cache initial position of all elements\n    var cacheBlocks = function() {\n      for (var i = 0; i < self.elems.length; i++){\n        var block = createBlock(self.elems[i]);\n        blocks.push(block);\n      }\n    };\n\n\n    // Let's kick this script off\n    // Build array for cached element values\n    var init = function() {\n      for (var i = 0; i < blocks.length; i++){\n        self.elems[i].style.cssText = blocks[i].style;\n      }\n\n      blocks = [];\n\n      screenY = window.innerHeight;\n      screenX = window.innerWidth;\n      currentBreakpoint = getCurrentBreakpoint(screenX);\n\n      setPosition();\n\n      cacheBlocks();\n\n      animate();\n\n      // If paused, unpause and set listener for window resizing events\n      if (pause) {\n        window.addEventListener('resize', init);\n        pause = false;\n        // Start the loop\n        update();\n      }\n    };\n\n    // We want to cache the parallax blocks'\n    // values: base, top, height, speed\n    // el: is dom object, return: el cache values\n    var createBlock = function(el) {\n      var dataPercentage = el.getAttribute( 'data-rellax-percentage' );\n      var dataSpeed = el.getAttribute( 'data-rellax-speed' );\n      var dataXsSpeed = el.getAttribute( 'data-rellax-xs-speed' );\n      var dataMobileSpeed = el.getAttribute( 'data-rellax-mobile-speed' );\n      var dataTabletSpeed = el.getAttribute( 'data-rellax-tablet-speed' );\n      var dataDesktopSpeed = el.getAttribute( 'data-rellax-desktop-speed' );\n      var dataVerticalSpeed = el.getAttribute('data-rellax-vertical-speed');\n      var dataHorizontalSpeed = el.getAttribute('data-rellax-horizontal-speed');\n      var dataVericalScrollAxis = el.getAttribute('data-rellax-vertical-scroll-axis');\n      var dataHorizontalScrollAxis = el.getAttribute('data-rellax-horizontal-scroll-axis');\n      var dataZindex = el.getAttribute( 'data-rellax-zindex' ) || 0;\n      var dataMin = el.getAttribute( 'data-rellax-min' );\n      var dataMax = el.getAttribute( 'data-rellax-max' );\n      var dataMinX = el.getAttribute('data-rellax-min-x');\n      var dataMaxX = el.getAttribute('data-rellax-max-x');\n      var dataMinY = el.getAttribute('data-rellax-min-y');\n      var dataMaxY = el.getAttribute('data-rellax-max-y');\n      var mapBreakpoints;\n      var breakpoints = true;\n\n      if (!dataXsSpeed && !dataMobileSpeed && !dataTabletSpeed && !dataDesktopSpeed) {\n        breakpoints = false;\n      } else {\n        mapBreakpoints = {\n          'xs': dataXsSpeed,\n          'sm': dataMobileSpeed,\n          'md': dataTabletSpeed,\n          'lg': dataDesktopSpeed\n        };\n      }\n\n      // initializing at scrollY = 0 (top of browser), scrollX = 0 (left of browser)\n      // ensures elements are positioned based on HTML layout.\n      //\n      // If the element has the percentage attribute, the posY and posX needs to be\n      // the current scroll position's value, so that the elements are still positioned based on HTML layout\n      var wrapperPosY = self.options.wrapper ? self.options.wrapper.scrollTop : (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);\n      // If the option relativeToWrapper is true, use the wrappers offset to top, subtracted from the current page scroll.\n      if (self.options.relativeToWrapper) {\n        var scrollPosY = (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);\n        wrapperPosY = scrollPosY - self.options.wrapper.offsetTop;\n      }\n      var posY = self.options.vertical ? ( dataPercentage || self.options.center ? wrapperPosY : 0 ) : 0;\n      var posX = self.options.horizontal ? ( dataPercentage || self.options.center ? self.options.wrapper ? self.options.wrapper.scrollLeft : (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft) : 0 ) : 0;\n\n      var blockTop = posY + el.getBoundingClientRect().top;\n      var blockHeight = el.clientHeight || el.offsetHeight || el.scrollHeight;\n\n      var blockLeft = posX + el.getBoundingClientRect().left;\n      var blockWidth = el.clientWidth || el.offsetWidth || el.scrollWidth;\n\n      // apparently parallax equation everyone uses\n      var percentageY = dataPercentage ? dataPercentage : (posY - blockTop + screenY) / (blockHeight + screenY);\n      var percentageX = dataPercentage ? dataPercentage : (posX - blockLeft + screenX) / (blockWidth + screenX);\n      if(self.options.center){ percentageX = 0.5; percentageY = 0.5; }\n\n      // Optional individual block speed as data attr, otherwise global speed\n      var speed = (breakpoints && mapBreakpoints[currentBreakpoint] !== null) ? Number(mapBreakpoints[currentBreakpoint]) : (dataSpeed ? dataSpeed : self.options.speed);\n      var verticalSpeed = dataVerticalSpeed ? dataVerticalSpeed : self.options.verticalSpeed;\n      var horizontalSpeed = dataHorizontalSpeed ? dataHorizontalSpeed : self.options.horizontalSpeed;\n\n      // Optional individual block movement axis direction as data attr, otherwise gobal movement direction\n      var verticalScrollAxis = dataVericalScrollAxis ? dataVericalScrollAxis : self.options.verticalScrollAxis;\n      var horizontalScrollAxis = dataHorizontalScrollAxis ? dataHorizontalScrollAxis : self.options.horizontalScrollAxis;\n\n      var bases = updatePosition(percentageX, percentageY, speed, verticalSpeed, horizontalSpeed);\n\n      // ~~Store non-translate3d transforms~~\n      // Store inline styles and extract transforms\n      var style = el.style.cssText;\n      var transform = '';\n\n      // Check if there's an inline styled transform\n      var searchResult = /transform\\s*:/i.exec(style);\n      if (searchResult) {\n        // Get the index of the transform\n        var index = searchResult.index;\n\n        // Trim the style to the transform point and get the following semi-colon index\n        var trimmedStyle = style.slice(index);\n        var delimiter = trimmedStyle.indexOf(';');\n\n        // Remove \"transform\" string and save the attribute\n        if (delimiter) {\n          transform = \" \" + trimmedStyle.slice(11, delimiter).replace(/\\s/g,'');\n        } else {\n          transform = \" \" + trimmedStyle.slice(11).replace(/\\s/g,'');\n        }\n      }\n\n      return {\n        baseX: bases.x,\n        baseY: bases.y,\n        top: blockTop,\n        left: blockLeft,\n        height: blockHeight,\n        width: blockWidth,\n        speed: speed,\n        verticalSpeed: verticalSpeed,\n        horizontalSpeed: horizontalSpeed,\n        verticalScrollAxis: verticalScrollAxis,\n        horizontalScrollAxis: horizontalScrollAxis,\n        style: style,\n        transform: transform,\n        zindex: dataZindex,\n        min: dataMin,\n        max: dataMax,\n        minX: dataMinX,\n        maxX: dataMaxX,\n        minY: dataMinY,\n        maxY: dataMaxY\n      };\n    };\n\n    // set scroll position (posY, posX)\n    // side effect method is not ideal, but okay for now\n    // returns true if the scroll changed, false if nothing happened\n    var setPosition = function() {\n      var oldY = posY;\n      var oldX = posX;\n\n      posY = self.options.wrapper ? self.options.wrapper.scrollTop : (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;\n      posX = self.options.wrapper ? self.options.wrapper.scrollLeft : (document.documentElement || document.body.parentNode || document.body).scrollLeft || window.pageXOffset;\n      // If option relativeToWrapper is true, use relative wrapper value instead.\n      if (self.options.relativeToWrapper) {\n        var scrollPosY = (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;\n        posY = scrollPosY - self.options.wrapper.offsetTop;\n      }\n\n\n      if (oldY != posY && self.options.vertical) {\n        // scroll changed, return true\n        return true;\n      }\n\n      if (oldX != posX && self.options.horizontal) {\n        // scroll changed, return true\n        return true;\n      }\n\n      // scroll did not change\n      return false;\n    };\n\n    // Ahh a pure function, gets new transform value\n    // based on scrollPosition and speed\n    // Allow for decimal pixel values\n    var updatePosition = function(percentageX, percentageY, speed, verticalSpeed, horizontalSpeed) {\n      var result = {};\n      var valueX = ((horizontalSpeed ? horizontalSpeed : speed) * (100 * (1 - percentageX)));\n      var valueY = ((verticalSpeed ? verticalSpeed : speed) * (100 * (1 - percentageY)));\n\n      result.x = self.options.round ? Math.round(valueX) : Math.round(valueX * 100) / 100;\n      result.y = self.options.round ? Math.round(valueY) : Math.round(valueY * 100) / 100;\n\n      return result;\n    };\n\n    // Remove event listeners and loop again\n    var deferredUpdate = function() {\n      window.removeEventListener('resize', deferredUpdate);\n      window.removeEventListener('orientationchange', deferredUpdate);\n      (self.options.wrapper ? self.options.wrapper : window).removeEventListener('scroll', deferredUpdate);\n      (self.options.wrapper ? self.options.wrapper : document).removeEventListener('touchmove', deferredUpdate);\n\n      // loop again\n      loopId = loop(update);\n    };\n\n    // Loop\n    var update = function() {\n      if (setPosition() && pause === false) {\n        animate();\n\n        // loop again\n        loopId = loop(update);\n      } else {\n        loopId = null;\n\n        // Don't animate until we get a position updating event\n        window.addEventListener('resize', deferredUpdate);\n        window.addEventListener('orientationchange', deferredUpdate);\n        (self.options.wrapper ? self.options.wrapper : window).addEventListener('scroll', deferredUpdate, supportsPassive ? { passive: true } : false);\n        (self.options.wrapper ? self.options.wrapper : document).addEventListener('touchmove', deferredUpdate, supportsPassive ? { passive: true } : false);\n      }\n    };\n\n    // Transform3d on parallax element\n    var animate = function() {\n      var positions;\n      for (var i = 0; i < self.elems.length; i++){\n        // Determine relevant movement directions\n        var verticalScrollAxis = blocks[i].verticalScrollAxis.toLowerCase();\n        var horizontalScrollAxis = blocks[i].horizontalScrollAxis.toLowerCase();\n        var verticalScrollX = verticalScrollAxis.indexOf(\"x\") != -1 ? posY : 0;\n        var verticalScrollY = verticalScrollAxis.indexOf(\"y\") != -1 ? posY : 0;\n        var horizontalScrollX = horizontalScrollAxis.indexOf(\"x\") != -1 ? posX : 0;\n        var horizontalScrollY = horizontalScrollAxis.indexOf(\"y\") != -1 ? posX : 0;\n\n        var percentageY = ((verticalScrollY + horizontalScrollY - blocks[i].top + screenY) / (blocks[i].height + screenY));\n        var percentageX = ((verticalScrollX + horizontalScrollX - blocks[i].left + screenX) / (blocks[i].width + screenX));\n\n        // Subtracting initialize value, so element stays in same spot as HTML\n        positions = updatePosition(percentageX, percentageY, blocks[i].speed, blocks[i].verticalSpeed, blocks[i].horizontalSpeed);\n        var positionY = positions.y - blocks[i].baseY;\n        var positionX = positions.x - blocks[i].baseX;\n\n        // The next two \"if\" blocks go like this:\n        // Check if a limit is defined (first \"min\", then \"max\");\n        // Check if we need to change the Y or the X\n        // (Currently working only if just one of the axes is enabled)\n        // Then, check if the new position is inside the allowed limit\n        // If so, use new position. If not, set position to limit.\n\n        // Check if a min limit is defined\n        if (blocks[i].min !== null) {\n          if (self.options.vertical && !self.options.horizontal) {\n            positionY = positionY <= blocks[i].min ? blocks[i].min : positionY;\n          }\n          if (self.options.horizontal && !self.options.vertical) {\n            positionX = positionX <= blocks[i].min ? blocks[i].min : positionX;\n          }\n        }\n\n        // Check if directional min limits are defined\n        if (blocks[i].minY != null) {\n            positionY = positionY <= blocks[i].minY ? blocks[i].minY : positionY;\n        }\n        if (blocks[i].minX != null) {\n            positionX = positionX <= blocks[i].minX ? blocks[i].minX : positionX;\n        }\n\n        // Check if a max limit is defined\n        if (blocks[i].max !== null) {\n          if (self.options.vertical && !self.options.horizontal) {\n            positionY = positionY >= blocks[i].max ? blocks[i].max : positionY;\n          }\n          if (self.options.horizontal && !self.options.vertical) {\n            positionX = positionX >= blocks[i].max ? blocks[i].max : positionX;\n          }\n        }\n\n        // Check if directional max limits are defined\n        if (blocks[i].maxY != null) {\n            positionY = positionY >= blocks[i].maxY ? blocks[i].maxY : positionY;\n        }\n        if (blocks[i].maxX != null) {\n            positionX = positionX >= blocks[i].maxX ? blocks[i].maxX : positionX;\n        }\n\n        var zindex = blocks[i].zindex;\n\n        // Move that element\n        // (Set the new translation and append initial inline transforms.)\n        var translate = 'translate3d(' + (self.options.horizontal ? positionX : '0') + 'px,' + (self.options.vertical ? positionY : '0') + 'px,' + zindex + 'px) ' + blocks[i].transform;\n        self.elems[i].style[transformProp] = translate;\n      }\n      self.options.callback(positions);\n    };\n\n    self.destroy = function() {\n      for (var i = 0; i < self.elems.length; i++){\n        self.elems[i].style.cssText = blocks[i].style;\n      }\n\n      // Remove resize event listener if not pause, and pause\n      if (!pause) {\n        window.removeEventListener('resize', init);\n        pause = true;\n      }\n\n      // Clear the animation loop to prevent possible memory leak\n      clearLoop(loopId);\n      loopId = null;\n    };\n\n    // Init\n    init();\n\n    // Allow to recalculate the initial values whenever we want\n    self.refresh = init;\n\n    return self;\n  };\n  return Rellax;\n}));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}